Build Instructions

1) to build the executable jar type "mvn package"

2) to build and run the tests "mvn install"

3) to run the tests "mvn test"


The main class JvmResearch.java  runs two main processes

1) A simple BenchMark to measure the memory footprint of the 
thread safe Collection classes in the java.util.concurrent.*
package

2) A simple Thread aggregation process that collates data on all 
the threads in the JVM at the time the process is called

	see below for notes on these processes


An  initial tool for profiling, tracing and obtaining  stack traces is 
"Java VisualVM"  a standard tool from 1.6.07 in the java SDK bin directory

In the SDK bin directory or anywhere else if your path is set a shell cmd 
"jvisualvm"  will run the VisualVM tool. For the first run the tool calibrates 
performance so for best results run the tool for the first time as the only 
process running on your machine.

Notes on process 1)

Many Java developers are in the early stages not only of learning to write concurrent programs
but in understanding the implications of concurrency for the Java Memory model (JMM). 
Studying concurrency and the JMM is a good way to discover the subtleties of multithreaded programming.
For example race conditions. The synchronised maps and lists in the java.util.concurrent.* package
will help you master the subtleties and become more familiar with the idioms.
For example we compare some of the "Collections.synchronized" of Java 1.4 classes with the more modern
java.util.concurrent.* Java 1.5. The "Collections.synchronized" can suffer from a symmetric lock 
deadlock scenario where two or more threads refuse to release a lock on a resource. The 
java.util.concurrent.CopyOnWriteArrayList gets around this by cloning a copy of its underlying
List for every write operation. Does this extra machinery have a significant impact for  JMM
run the code and discover for yourself!

Notes on process 2)

While there are many heap inspection tools available this is not always as helpful as you may want
and require command line parameters that can be a pain to implement, or scripts to maintain. See for
yourself how easy it is to program a thread dump utility in the code that you can call at any point 
in the program using the Future and Callable interfaces from the java.util.concurrent.* package








